import{_ as a,c as i,o as e,ae as n}from"./chunks/framework.DO_qJNgM.js";const t="/his-note/assets/image37.D9XCCzOu.png",l="/his-note/assets/image38.BTi_FVSS.png",p="/his-note/assets/image39.YVDT_32L.png",o="/his-note/assets/image40.zyAhXweq.png",d="/his-note/assets/image41.Dgbzl5lw.png",h="/his-note/assets/image42.CiTyMtPG.png",c="/his-note/assets/image43.vwg2BMyf.png",r="/his-note/assets/image44.C1UOqaYm.png",k="/his-note/assets/image45.Buc_-mLl.png",g="/his-note/assets/image46.Bwlw7VWB.png",E="/his-note/assets/image47.P59Y_8R8.png",b="/his-note/assets/image48.D2_aK12n.png",q=JSON.parse('{"title":"每日小Tip","description":"","frontmatter":{},"headers":[],"relativePath":"springboot/tip.md","filePath":"springboot/tip.md"}'),y={name:"springboot/tip.md"};function u(v,s,m,F,C,D){return e(),i("div",null,s[0]||(s[0]=[n('<h1 id="每日小tip" tabindex="-1">每日小Tip <a class="header-anchor" href="#每日小tip" aria-label="Permalink to &quot;每日小Tip&quot;">​</a></h1><br><br><p><img src="'+t+'" alt=""><img src="'+l+'" alt=""><img src="'+p+`" alt=""></p><br><br><h2 id="前端允许跨域请求" tabindex="-1">前端允许跨域请求: <a class="header-anchor" href="#前端允许跨域请求" aria-label="Permalink to &quot;前端允许跨域请求:&quot;">​</a></h2><div class="language-Vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">server:{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    host: &quot;localhost&quot;,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    port: 7600,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cors: true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><br><br><h2 id="大型网站在负载较大的情况下加载页面也很快是为什么" tabindex="-1">大型网站在负载较大的情况下加载页面也很快是为什么？ <a class="header-anchor" href="#大型网站在负载较大的情况下加载页面也很快是为什么" aria-label="Permalink to &quot;大型网站在负载较大的情况下加载页面也很快是为什么？&quot;">​</a></h2><p>这是因为大型的电商网站都会把首页的数据缓存到内存当中，当前端项目渲染首页的时候，后端只需要从内存中提取数据即可，不需要走数据库，所以首页加载速度就明显提升了。</p><br><br><h2 id="vue命令行指令" tabindex="-1">Vue命令行指令： <a class="header-anchor" href="#vue命令行指令" aria-label="Permalink to &quot;Vue命令行指令：&quot;">​</a></h2><ol><li>$ <code>git status</code>:查看暂存区情况，绿色已上传，红色未上传。</li></ol><br><br><h2 id="java标准库" tabindex="-1">Java标准库 <a class="header-anchor" href="#java标准库" aria-label="Permalink to &quot;Java标准库&quot;">​</a></h2><p>Java标准库是一组预定义的类和接口，为Java程序提供了广泛的功能。这些库位于<code>java.</code>和<code>javax.</code>包以及一些其他位置，是Java编程语言的核心部分。<br><strong>核心Java类库:</strong></p><ul><li><code>java.lang</code>包:包含所有Java程序都需要的类，如<code>String</code>、<code>Math</code>、<code>System</code>等。这个包由解释程序自动加载，不需要显式说明（不需要用<code>import</code>）。</li><li><code>java.util</code>包：包含集合框架（如<code>List</code>、<code>Set</code>、<code>Map</code>），日期和时间API（如<code>Calendar</code>、<code>Date</code>、<code>TimeZone</code>）,随机数生成器（<code>Random</code>）等</li><li><code>java.io</code>包：包含用于文件和流操作的类，如<code>File</code>、<code>FileInputStream</code>、<code>BufferedReader</code>、<code>BufferedWriter</code>,这些类提供了对不同输入和输出设备读写数据的支持。</li><li><code>java.nio</code>包：提供非阻塞I/O类库，用于提高I/O操作的性能和可扩展性。</li><li><code>java.net</code>包：包含用于网络编程的类，如<code>URL</code>、<code>Socket</code>、<code>Serversocket</code>、<code>InetAddress</code>等。</li><li><code>java.sql</code>包：提供与数据库交互的接口，如<code>Connection</code>、<code>Statement</code>、<code>ResultSet</code>等。<br> 其他常用包：</li><li><code>java.awt</code>、<code>javax.swing</code>:用于创建图形用户界面（GUI）的类库。</li><li><code>java.security</code>:包含用于加密、访问控制、证书、密钥生成和管理的类。</li><li><code>java.util.concurrent</code>:包含用于并发编程的类，如<code>Thread</code>、<code>Runnable</code>、<code>ExecutorService</code>、<code>ConutDownLatch</code>等。</li></ul><br><br><h2 id="java-api文档" tabindex="-1">Java API文档 <a class="header-anchor" href="#java-api文档" aria-label="Permalink to &quot;Java API文档&quot;">​</a></h2><p>是一个详细的在线资源，其中包含了关于Java标准库中每个类和接口的详细信息，包括其方法和属性描述、示例代码和常见问题解答，可以通过<code>Oracle</code>官方网站来访问这些文档。</p><br><br><h2 id="java类" tabindex="-1">Java类 <a class="header-anchor" href="#java类" aria-label="Permalink to &quot;Java类&quot;">​</a></h2><h3 id="_1" tabindex="-1">@1 <a class="header-anchor" href="#_1" aria-label="Permalink to &quot;@1&quot;">​</a></h3><p><code>RoutimeException</code>:是Java标准库中的一个类，继承自<code>Exception</code>,是所有运行时异常的基类。<br></p><p>未检查异常：与<code>IOException</code>等已检查异常不同，<code>RoutimeException</code>不需要在方法签名中声明，也不强制要求使用<code>try-catch</code>块进行捕获。<br> 典型错误类型:<code>RoutimeException</code>通常用于描述程序逻辑上的错误，编译器无法检查这些错误，通常是程序员的疏忽或输入不当导致的。</p><br><br><h2 id="全局处理异常" tabindex="-1">全局处理异常 <a class="header-anchor" href="#全局处理异常" aria-label="Permalink to &quot;全局处理异常&quot;">​</a></h2><p><code>SpringBoot</code>提供了全局处理异常的技术，只要我们给某个Java类用上<code>@RestControllerAdvice</code>注解，这个类就能捕获SpringBoot项目中所有的异常，然后统一处理，即把异常的详情信息输出到后端的日志里面，然后将精简的异常信息返回给前端项目。</p><br><br><h2 id="异步线程" tabindex="-1">异步线程 <a class="header-anchor" href="#异步线程" aria-label="Permalink to &quot;异步线程&quot;">​</a></h2><p>SpringBoot会把某些任务对象推给线程池去执行。之所以叫异步线程，是因为线程池中的线程相当于主线程来说就是异步的：主线程把任务推给线程池，线程池挑选某个空闲线程去执行这个任务，主线程并不会等待线程池的执行结果，主线程会继续往下做别的事情。</p><br><br><h2 id="注解" tabindex="-1">注解 <a class="header-anchor" href="#注解" aria-label="Permalink to &quot;注解&quot;">​</a></h2><ol><li><p><code>@EnableAsync</code>:主类加上此注解后，SpringBoot就开启了异步线程的功能。这样某些任务就可以推送给线程池去执行。 <br></p></li><li><p><code>@Async</code>:向线程池推送任务去执行。<br> 定义了一个Java类，名字叫什么无所谓：</p></li></ol><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CheckupWorkAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //声明一个方法,推给线程池去执行</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //注解括号里的是线程池执行者的名字</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;AsyncTaskExecutor&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createReport</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Integer </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><br><ol start="3"><li><p><code>@Data</code>：生成get、set方法。 <br></p></li><li><p><code>@NotBlank</code>:验证变量的值是否为空值或者空字符串。</p></li></ol><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NotBlank</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">message</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;username不能为空&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String username;</span></span></code></pre></div><br><ol start="5"><li><code>@RestController</code>:接口方法返回对象，转换为json文本。在接口类里面使用，因为如果把当前的接口返回给对应的客户端，肯定需要把后端的数据转化为json文本，对应的客户端才能够更好的进行处理。</li></ol><br><ol start="6"><li><code>@RequestMapping(&quot;/user&quot;)</code>:加一级类级别的映射,到时候客户端去访问当前的接口的时候，即<code>localhost:8088/user/**</code>来访问后面的接口。</li></ol><br><br><ol start="7"><li><code>@Repository</code>:将当前类注册为spring的bean；来表示数据访问层的bean。<br><code>@Service</code>:将当前类注册为spring的bean；来表示业务逻辑类的bean。<br><code>@Component</code>:将当前类注册为spring的bean。<br> 这样分开来做职责更加明确。</li></ol><h2 id="构建" tabindex="-1">构建 <a class="header-anchor" href="#构建" aria-label="Permalink to &quot;构建&quot;">​</a></h2><ol><li>在Java文件夹下的<code>com.example.his.api</code>包下创建<code>mis</code>包，在<code>mis</code>包下新建一个包叫<code>service</code>,在<code>service</code>包下新建一个接口叫<code>UserService</code>,在接口里面声明抽象方法。接下来去到实现类里面把抽象方法实现一下，在package<code>service</code>底下新建一个包叫<code>Impl</code>，在这个包里面新建一个Java类叫<code>UserServiceImpl</code>。并且再<code>mis</code>包下边新建一个包叫<code>controller</code>,如果写Web方法就放在<code>controller</code>的实现类里面。 <img src="`+o+`" alt=""></li></ol><br><br><h2 id="引用变量" tabindex="-1">引用变量 <a class="header-anchor" href="#引用变量" aria-label="Permalink to &quot;引用变量&quot;">​</a></h2><p>在Java中，引用变量是指向对象的变量，它们存储的是对象在内存中的地址，而不是对象本身的值。引用变量的主要特点是通过它们可以访问对象，并且可以通过赋值操作将一个引用变量的值赋给另一个引用变量。引用变量包含了对对象的引用，假如定义一个类<code>Circle</code>，这个类是一种引用类型，该类类型的变量可以引用该类的一个实例：</p><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Circle circle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Circle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//参数表示半径</span></span></code></pre></div><p>这个例子中，变量<code>circle</code>的值保存的是一个引用，它指明这个<code>Circle</code>对象的内容存储在内存的什么位置。 <br></p><p><strong>基本类型变量和引用类型变量的区别：</strong><br> 每个变量都代表一个保存了存储值的内存位置，声明一个变量时，就是在告诉编辑器这个变量可以存放什么类型的值。<br> 基本类型变量：在内存中存储的是一个基本类型值，可以在栈中直接分配内存，例如<code>int a = 1;</code>中变量a的值就是int值1。<br> 引用类型变量： 对应内存所存储的值是一个引用，是对象的存储地址，对象的引用在栈中，对象实际存放在堆中。</p><br><br><h2 id="名词" tabindex="-1">名词 <a class="header-anchor" href="#名词" aria-label="Permalink to &quot;名词&quot;">​</a></h2><ol><li><code>Dao</code>：通常指的是数据访问对象（Data Access Object）。</li></ol><br><br><h2 id="接口" tabindex="-1">接口 <a class="header-anchor" href="#接口" aria-label="Permalink to &quot;接口&quot;">​</a></h2><p>接口是一种定义方法签名的类型，类可以实现接口来提供具体的方法实现。在Java、ts中，接口是一种约定规范，用于定义类或对象的行为，但不包含具体实现。<br> 核心作用：<br></p><ol><li>解耦：分离“做什么”（接口定义）和“怎么做”（具体实现）。</li><li>多态：允许不同类通过同一接口提供不同实现。</li><li>标准化：强制实现类遵守统一的方法签名。</li></ol><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//定义接口</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> eat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//抽象方法（无具体实现）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//类实现接口</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Dog</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> eat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;狗吃骨头&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;狗趴着睡&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><br><br><h2 id="springboot" tabindex="-1">SpringBoot <a class="header-anchor" href="#springboot" aria-label="Permalink to &quot;SpringBoot&quot;">​</a></h2><p><code>SpringBoot</code>是一个脚手架，用于快速搭建一个基于<code>Spring</code>的<code>Web</code>应用，创建即可开发业务代码。其设计目的是用来简化<code>Spring</code>应用的初始搭建以及开发过程。 <br></p><p><strong>优点：</strong><br> （1）快速构建一个独立的<code>Spring</code>应用程序；<br> （2）嵌入了<code>Tomcat</code>、<code>Jetty</code>，无需部署<code>WAR</code>包，只需要将<code>SpringBoo</code>t打成一个<code>Jar</code>包，直接通过<code>Java</code>跟<code>Jar</code>就可以直接启动<code>Web</code>应用；<br> （3）提供了各种各样的<code>starter</code>，比如说要继承<code>springvc</code>，就有<code>springvc</code>对应的<code>starter</code>；如果要集成<code>redis</code>，就用<code>redis</code>对应的<code>starter</code>，这样就可以简化Maven配置，并且还帮助管理版本号，减少版本不一致带来的版本冲突的问题；<br> （4）对<code>Spring</code>和第三方库提供默认配置，也称为自动配置类，采用约定大于配置的方式，只要添加了对应的<code>starter</code>依赖，就会包含对应的自动配置，从而做到开箱即用。<br> （5）无需配置XML。 <br></p><p>比如对一个用户系统的用户模块，后端通过三层的结构:<br> 第一层是控制层，通过springmvc来实现，：<code>@RestController</code>、<code>@Controller</code>。<br> 业务层写一些业务逻辑代码,:<code>@Service</code>。<br> 数据访问层去提供数据库操作的功能，通过SpringData JPA来实现，是Spring生态自带的，可以无缝的进行集成。 <br></p><p><img src="`+d+'" alt=""><img src="'+h+'" alt=""><img src="'+c+'" alt=""><br></p><p>想要一个实体类映射为数据库中的一个表，因为springdata jpa是面向对象的方式操作数据库，所以可以加上一个<code>@Table</code>，再加上一个<code>@Entity</code>,这样就相当于把这个类映射成了一个表。<code>@Table</code>默认会将类名当作表名，所以需要在注解中声明一下：<br><img src="'+r+'" alt=""><br> 报错说要添加主键id，解决方法：加上@Id注解，将user_id作为主键id。id是以什么样的方式生成，如果希望它是自动生成的方式，加上<code>@GeneratedValue</code>,并指定其策略，比如说<strong>自增</strong>的方式： <img src="'+k+'" alt=""><br> 通过可以把字段名用<code>@Column</code>改一下，默认情况下会把属性名作为数据库表的字段名，所以可以映射一下：<br><img src="'+g+'" alt=""><br> 如果想项目运行的时候自动生成数据库的表，就需要在<code>application.properties</code>配置文件中加上</p><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">spring.jpa.hibernate.ddl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">auto</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">update</span></span></code></pre></div><p>此外它到时候会生成数据库的SQL语句，希望让他打印在控制台上，可是如果不格式化一下，即<code>format_sql</code>一下，它会打印在一行上，不方便我们阅读：</p><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">spring.jpa.properties.hibernate.format_sql</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span></code></pre></div><p>此外：显示sql：</p><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">spring.jpa.show</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sql</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span></code></pre></div><p>利用这种springdata jpa面向对象的数据库持久化方式可以增加开发效率。 <img src="'+E+`" alt=""></p><br><br><h2 id="问题" tabindex="-1">问题 <a class="header-anchor" href="#问题" aria-label="Permalink to &quot;问题&quot;">​</a></h2><h3 id="_1-1" tabindex="-1">@1 <a class="header-anchor" href="#_1-1" aria-label="Permalink to &quot;@1&quot;">​</a></h3><p>错误：Java：错误：不支持发行版本19 解答：通常是由于项目配置的Java版本与本地安装的JDK版本不一致导致的。</p><br><br><h2 id="rest" tabindex="-1">Rest <a class="header-anchor" href="#rest" aria-label="Permalink to &quot;Rest&quot;">​</a></h2><p>其实就是客户端根据不同的请求方法：<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>。当我们发起任何一个请求，比如打开任意一个网页，到我们服务端都会带一个请求头，这个请求头就会有它当前的请求方法。<code>GET</code>表查询，用<code>@GetMapping</code>。<code>POST</code>表新增，用<code>@PostMapping</code>来进行映射。<code>PUT</code>表修改，用<code>@PutMapping</code>。<code>DELETE</code>表删除，用<code>@DeleteMapping</code>。<br> 例如增加：</p><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">PostMapping</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这里<code>add()</code>需要接受一个客户端传过来的<code>user</code>信息,当然还可以直接把这个<code>User</code>类用于参数接收，即：</p><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">PostMapping</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(User user){</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>但对于规范有要求的项目，一般都会用<code>DTO</code>的类即数据传输类来去接收这些客户端请求过来的参数。因为客户端请求过来的参数不一定就是pojo类所包含的这几个参数： <img src="`+b+`" alt=""> 我的这个pojo类只有四个参数，用User类来接收完全可以。对于有规范要求的项目，可以在<code>pojo</code>里面再加一个<code>dto</code>的包，创建一个<code>UserDto</code>类。然后将<code>User</code>类里面的声明变量复制一份到<code>UserDto</code>中，于是将<code>UserDto</code>作为前端参数的一个接收。<br> 最好加上一个<code>@RequestBody</code>,传进<code>UserDto</code>来的是一个json文本，会帮我们转换成对象：</p><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">PostMapping</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RequestBody</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UserDto user){</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>通常一个业务逻辑类会创建一个接口，这样面向接口进行编程，对于以后的扩展性、维护性会更强。学了设计模式就会明白接口对于扩展性的好处。<br> 在业务逻辑类中标记成spring的bean之后，就可以在接口包中用<code>@Autowired</code>自动装配进来，用userService来进行接收。</p><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">IUserService userService;</span></span></code></pre></div><p>在业务逻辑层调用数据访问的方法，则在数据库访问层<code>repository</code>新建一个类。如果我们使用的是springdata jpa，因为对应的增删查改的方法不需要我们自己去实现，我们只需要去继承一个<code>CrudRepository</code>，这个接口会自动帮我们实现好。<br></p><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UserRepository</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CrudRepository</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这时可以去指定两个类型：第一个类型是要操作哪个<code>pojo</code>类：<code>pojo</code>包的<code>User</code>pojo类,第二个类型是你当前这个<code>User</code>类的主键Id是什么数据类型：<code>Integer</code>：</p><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Repository</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //当前类注册为spring的Bean</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UserRepository</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CrudRepository</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div>`,107)]))}const _=a(y,[["render",u]]);export{q as __pageData,_ as default};
