import{_ as e,c as i,o as s,ae as o}from"./chunks/framework.DO_qJNgM.js";const t="/his-note/assets/image37.D9XCCzOu.png",n="/his-note/assets/image38.BTi_FVSS.png",c="/his-note/assets/image39.YVDT_32L.png",b=JSON.parse('{"title":"每日小Tip","description":"","frontmatter":{},"headers":[],"relativePath":"springboot/tip.md","filePath":"springboot/tip.md"}'),d={name:"springboot/tip.md"};function l(r,a,p,h,k,u){return s(),i("div",null,a[0]||(a[0]=[o('<h1 id="每日小tip" tabindex="-1">每日小Tip <a class="header-anchor" href="#每日小tip" aria-label="Permalink to &quot;每日小Tip&quot;">​</a></h1><br><br><p><img src="'+t+'" alt=""><img src="'+n+'" alt=""><img src="'+c+`" alt=""></p><br><br><h2 id="前端允许跨域请求" tabindex="-1">前端允许跨域请求: <a class="header-anchor" href="#前端允许跨域请求" aria-label="Permalink to &quot;前端允许跨域请求:&quot;">​</a></h2><div class="language-Vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">server:{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    host: &quot;localhost&quot;,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    port: 7600,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cors: true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><br><br><h2 id="大型网站在负载较大的情况下加载页面也很快是为什么" tabindex="-1">大型网站在负载较大的情况下加载页面也很快是为什么？ <a class="header-anchor" href="#大型网站在负载较大的情况下加载页面也很快是为什么" aria-label="Permalink to &quot;大型网站在负载较大的情况下加载页面也很快是为什么？&quot;">​</a></h2><p>这是因为大型的电商网站都会把首页的数据缓存到内存当中，当前端项目渲染首页的时候，后端只需要从内存中提取数据即可，不需要走数据库，所以首页加载速度就明显提升了。</p><br><br><h2 id="vue命令行指令" tabindex="-1">Vue命令行指令： <a class="header-anchor" href="#vue命令行指令" aria-label="Permalink to &quot;Vue命令行指令：&quot;">​</a></h2><ol><li>$ <code>git status</code>:查看暂存区情况，绿色已上传，红色未上传。</li></ol><br><br><h2 id="java标准库" tabindex="-1">Java标准库 <a class="header-anchor" href="#java标准库" aria-label="Permalink to &quot;Java标准库&quot;">​</a></h2><p>Java标准库是一组预定义的类和接口，为Java程序提供了广泛的功能。这些库位于<code>java.</code>和<code>javax.</code>包以及一些其他位置，是Java编程语言的核心部分。<br><strong>核心Java类库:</strong></p><ul><li><code>java.lang</code>包:包含所有Java程序都需要的类，如<code>String</code>、<code>Math</code>、<code>System</code>等。这个包由解释程序自动加载，不需要显式说明（不需要用<code>import</code>）。</li><li><code>java.util</code>包：包含集合框架（如<code>List</code>、<code>Set</code>、<code>Map</code>），日期和时间API（如<code>Calendar</code>、<code>Date</code>、<code>TimeZone</code>）,随机数生成器（<code>Random</code>）等</li><li><code>java.io</code>包：包含用于文件和流操作的类，如<code>File</code>、<code>FileInputStream</code>、<code>BufferedReader</code>、<code>BufferedWriter</code>,这些类提供了对不同输入和输出设备读写数据的支持。</li><li><code>java.nio</code>包：提供非阻塞I/O类库，用于提高I/O操作的性能和可扩展性。</li><li><code>java.net</code>包：包含用于网络编程的类，如<code>URL</code>、<code>Socket</code>、<code>Serversocket</code>、<code>InetAddress</code>等。</li><li><code>java.sql</code>包：提供与数据库交互的接口，如<code>Connection</code>、<code>Statement</code>、<code>ResultSet</code>等。<br> 其他常用包：</li><li><code>java.awt</code>、<code>javax.swing</code>:用于创建图形用户界面（GUI）的类库。</li><li><code>java.security</code>:包含用于加密、访问控制、证书、密钥生成和管理的类。</li><li><code>java.util.concurrent</code>:包含用于并发编程的类，如<code>Thread</code>、<code>Runnable</code>、<code>ExecutorService</code>、<code>ConutDownLatch</code>等。</li></ul><br><br><h2 id="java-api文档" tabindex="-1">Java API文档 <a class="header-anchor" href="#java-api文档" aria-label="Permalink to &quot;Java API文档&quot;">​</a></h2><p>是一个详细的在线资源，其中包含了关于Java标准库中每个类和接口的详细信息，包括其方法和属性描述、示例代码和常见问题解答，可以通过<code>Oracle</code>官方网站来访问这些文档。</p><br><br><h2 id="java类" tabindex="-1">Java类 <a class="header-anchor" href="#java类" aria-label="Permalink to &quot;Java类&quot;">​</a></h2><h3 id="_1" tabindex="-1">@1 <a class="header-anchor" href="#_1" aria-label="Permalink to &quot;@1&quot;">​</a></h3><p><code>RoutimeException</code>:是Java标准库中的一个类，继承自<code>Exception</code>,是所有运行时异常的基类。<br></p><p>未检查异常：与<code>IOException</code>等已检查异常不同，<code>RoutimeException</code>不需要在方法签名中声明，也不强制要求使用<code>try-catch</code>块进行捕获。<br> 典型错误类型:<code>RoutimeException</code>通常用于描述程序逻辑上的错误，编译器无法检查这些错误，通常是程序员的疏忽或输入不当导致的。</p><br><br><h2 id="全局处理异常" tabindex="-1">全局处理异常 <a class="header-anchor" href="#全局处理异常" aria-label="Permalink to &quot;全局处理异常&quot;">​</a></h2><p><code>SpringBoot</code>提供了全局处理异常的技术，只要我们给某个Java类用上<code>@RestControllerAdvice</code>注解，这个类就能捕获SpringBoot项目中所有的异常，然后统一处理，即把异常的详情信息输出到后端的日志里面，然后将精简的异常信息返回给前端项目。</p><br><br><h2 id="异步线程" tabindex="-1">异步线程 <a class="header-anchor" href="#异步线程" aria-label="Permalink to &quot;异步线程&quot;">​</a></h2><p>SpringBoot会把某些任务对象推给线程池去执行。之所以叫异步线程，是因为线程池中的线程相当于主线程来说就是异步的：主线程把任务推给线程池，线程池挑选某个空闲线程去执行这个任务，主线程并不会等待线程池的执行结果，主线程会继续往下做别的事情。</p><br><br><h2 id="注解" tabindex="-1">注解 <a class="header-anchor" href="#注解" aria-label="Permalink to &quot;注解&quot;">​</a></h2><ol><li><p><code>@EnableAsync</code>:主类加上此注解后，SpringBoot就开启了异步线程的功能。这样某些任务就可以推送给线程池去执行。 <br></p></li><li><p><code>@Async</code>:向线程池推送任务去执行。<br> 定义了一个Java类，名字叫什么无所谓：</p></li></ol><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CheckupWorkAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //声明一个方法,推给线程池去执行</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //注解括号里的是线程池执行者的名字</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;AsyncTaskExecutor&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createReport</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Integer </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div>`,44)]))}const g=e(d,[["render",l]]);export{b as __pageData,g as default};
